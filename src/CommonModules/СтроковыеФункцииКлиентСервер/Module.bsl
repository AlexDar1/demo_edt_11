////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРОКАМИ

// Функция "расщепляет" строку на подстроки, используя заданный
//      разделитель. Разделитель может иметь любую длину.
//      Если в качестве разделителя задан пробел, рядом стоящие пробелы
//      считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//      игнорируются.
//      Например,
//      РазложитьСтрокуВМассивПодстрок(",один,,,два", ",") возвратит массив значений из пяти элементов,
//      три из которых - пустые строки, а
//      РазложитьСтрокуВМассивПодстрок(" один   два", " ") возвратит массив значений из двух элементов
//
//  Параметры:
//      Стр -           строка, которую необходимо разложить на подстроки.
//                      Параметр передается по значению.
//      Разделитель -   строка-разделитель, по умолчанию - запятая.
//
//  Возвращаемое значение:
//      массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				Если (СокрЛП(Стр) <> "") Тогда
					МассивСтрок.Добавить(Стр);
				КонецЕсли;
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз - 1));
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции 

// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
//
// Параметры:
//  Массив - Массив - массив элементов из которых необходимо получить строку
//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
//
// Возвращаемое значение:
//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
// 
Функция ПолучитьСтрокуИзМассиваПодстрок(Массив, Разделитель = ",") Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Каждого Элемент ИЗ Массив Цикл
		
		Подстрока = ?(ТипЗнч(Элемент) = Тип("Строка"), Элемент, Строка(Элемент));
		
		РазделительПодстрок = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + РазделительПодстрок + Подстрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Сравнить две строки версий.
//
// Параметры
//  СтрокаВерсии1  – Строка – номер версии в формате РР.{П|ПП}.ЗЗ.СС
//  СтрокаВерсии2  – Строка – второй сравниваемый номер версии
//
// Возвращаемое значение:
//   Число   – больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0.0", СтрокаВерсии2);
	Версия1 = РазложитьСтрокуВМассивПодстрок(Строка1, ".");
	Если Версия1.Количество() <> 4 Тогда
		ВызватьИсключение ПодставитьПараметрыВСтроку(
		                    НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = РазложитьСтрокуВМассивПодстрок(Строка2, ".");
	Если Версия2.Количество() <> 4 Тогда
		ВызватьИсключение ПодставитьПараметрыВСтроку(
	                         НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 3 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров
// начинается с единицы.
//
// Параметры
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%ИмяПараметра").
// Параметр<n>         - Строка - параметр
// Возвращаемое значение:
//   Строка   – текстовая строка с подставленными параметрами
//
// Пример:
// Строка = ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк");
//
Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1,	Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	Если СтрокаПодстановки = Неопределено ИЛИ СтрДлина(СтрокаПодстановки) = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	НачПозиция = 1;
	Позиция = 1;
	Пока Позиция <= СтрДлина(СтрокаПодстановки) Цикл
		СимволСтроки = Сред(СтрокаПодстановки, Позиция, 1);
		Если СимволСтроки <> "%" Тогда
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		Результат = Результат + Сред(СтрокаПодстановки, НачПозиция, Позиция - НачПозиция);
		Позиция = Позиция + 1;
		СимволСтроки = Сред(СтрокаПодстановки, Позиция, 1);
		
		Если СимволСтроки = "%" Тогда
			Позиция = Позиция + 1;
			НачПозиция = Позиция;
			Продолжить;
		КонецЕсли;
		
		Попытка
			НомерПараметра = Число(СимволСтроки);
		Исключение
			ВызватьИсключение НСтр("ru='Входная строка СтрокаПодстановки имеет неверный формат: %'" + СимволСтроки);
		КонецПопытки;
		
		Если СимволСтроки = "1" Тогда
			ЗначениеПараметра = Параметр1;
		ИначеЕсли СимволСтроки = "2" Тогда
			ЗначениеПараметра = Параметр2;
		ИначеЕсли СимволСтроки = "3" Тогда
			ЗначениеПараметра = Параметр3;
		ИначеЕсли СимволСтроки = "4" Тогда
			ЗначениеПараметра = Параметр4;
		ИначеЕсли СимволСтроки = "5" Тогда
			ЗначениеПараметра = Параметр5;
		ИначеЕсли СимволСтроки = "6" Тогда
			ЗначениеПараметра = Параметр6;
		ИначеЕсли СимволСтроки = "7" Тогда
			ЗначениеПараметра = Параметр7;
		ИначеЕсли СимволСтроки = "8" Тогда
			ЗначениеПараметра = Параметр8;
		ИначеЕсли СимволСтроки = "9" Тогда
			ЗначениеПараметра = Параметр9;
		Иначе
			ВызватьИсключение НСтр("ru='Входная строка СтрокаПодстановки имеет неверный формат: %'" + ЗначениеПараметра);
		КонецЕсли;
		Если ЗначениеПараметра = Неопределено Тогда
			ЗначениеПараметра = "";
		Иначе
			ЗначениеПараметра = Строка(ЗначениеПараметра);
		КонецЕсли;
		Результат = Результат + ЗначениеПараметра;
		Позиция = Позиция + 1;
		НачПозиция = Позиция;
	
	КонецЦикла;
	
	Если (НачПозиция <= СтрДлина(СтрокаПодстановки)) Тогда
		Результат = Результат + Сред(СтрокаПодстановки, НачПозиция, СтрДлина(СтрокаПодстановки) - НачПозиция + 1);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Подставляет параметры в строку. Неограниченное число параметров в строке.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров
// начинается с единицы.
//
// Параметры
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%1").
//  МассивПараметров   - Массив - массив строк, которые соответствуют параметрам в строке подстановки
//
// Возвращаемое значение:
//   Строка   – текстовая строка с подставленными параметрами
//
// Пример:
// МассивПараметров = Новый Массив;
// МассивПараметров = МассивПараметров.Добавить("Вася");
// МассивПараметров = МассивПараметров.Добавить("Зоопарк");
//
// Строка = ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), МассивПараметров);
//
Функция ПодставитьПараметрыВСтрокуИзМассива(Знач СтрокаПодстановки, Знач МассивПараметров) Экспорт
	
	СтрокаРезультата = СтрокаПодстановки;
	
	Для Индекс = 1 По МассивПараметров.Количество() Цикл
		ОбрИндекс = МассивПараметров.Количество() - Индекс + 1;
		Если Не ПустаяСтрока(МассивПараметров[ОбрИндекс-1]) Тогда
			СтрокаРезультата = СтрЗаменить(СтрокаРезультата, "%"+Строка(ОбрИндекс), МассивПараметров[ОбрИндекс-1]);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаРезультата;
	
КонецФункции

// Проверяет содержит ли строка только цифры.
//
// Параметры:
//  СтрокаПроверки - строка для проверки.
//  УчитыватьЛидирующиеНули - Булево - нужно ли учитывать лидирующие нули.
//  УчитыватьПробелы - Булево - нужно ли учитывать пробелы.
//
// Возвращаемое значение:
//  Истина       - строка содержит только цифры;
//  Ложь         - строка содержит не только цифры.
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, Знач УчитыватьЛидирующиеНули = Истина, Знач УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		//Возврат Истина; незнаю зачем была истина
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // ТолькоЦифрыВСтроке()

// Удаляет двойные кавычки с начала и конца строки, если они есть.
//
// Параметры:
//  Строка       - входная строка;
//
// Возвращаемое значение:
//  Строка - строка без двойных кавычек.
// 
Функция СократитьДвойныеКавычки(Знач Строка) Экспорт
	
	Результат = Строка;
	Пока Найти(Результат, """") = 1 Цикл
		Результат = Сред(Результат, 2); 
	КонецЦикла; 
	Пока Найти(Результат, """") = СтрДлина(Результат) Цикл
		Результат = Сред(Результат, 1, СтрДлина(Результат) - 1); 
	КонецЦикла; 
	Возврат Результат;
	
КонецФункции 

// Процедура удаляет из строки указанное количество символов справа
//
Процедура УдалитьПоследнийСимволВСтроке(Текст, ЧислоСимволов) Экспорт
	
	Текст = Лев(Текст, СтрДлина(Текст) - ЧислоСимволов);
	
КонецПроцедуры 

// Находит символ в строке с конца
//
Функция НайтиСимволСКонца(Знач СтрокаВся, Знач ОдинСимвол) Экспорт
	
	НачальнаяПозиция = 1; 
	ДлинаСтроки = СтрДлина(СтрокаВся);
	
	Для ТекущаяПозиция = 1 По СтрДлина(СтрокаВся) Цикл
		РеальнаяПозиция = ДлинаСтроки - ТекущаяПозиция + 1;
		ТекущийСимвол = Сред(СтрокаВся, РеальнаяПозиция, 1);
		Если ТекущийСимвол = ОдинСимвол Тогда
			Возврат РеальнаяПозиция;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

// Функция проверяет, является ли переданная в неё строка уникальным идентификатором
//
Функция ЭтоУникальныйИдентификатор(ИдентификаторСтрока) Экспорт
	
	УИСтрока = ИдентификаторСтрока;
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(УИСтрока) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Сч = 1 По СтрДлина(УИСтрока) Цикл
		Если КодСимвола(Шаблон, сч) = 88 И 
			((КодСимвола(УИСтрока, сч) < 48 ИЛИ КодСимвола(УИСтрока, сч) > 57) И (КодСимвола(УИСтрока, сч) < 97 или КодСимвола(УИСтрока, сч) > 102)) Тогда
			Возврат ложь; 
		 ИначеЕсли КодСимвола(Шаблон, сч) = 45 И КодСимвола(УИСтрока, сч) <> 45 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

// Формирует строку повторяющихся символов заданной длины
//
Функция СформироватьСтрокуСимволов(Символ, КоличествоСимволов) Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Индекс = 1 ПО КоличествоСимволов Цикл
		
		Результат = Результат + Символ;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Дополняет переданную в качестве первого параметра строку символами слева\справа до заданной длины и возвращает ее
// Незначащие символы слева и справа удаляются
// По умолчанию функция добавляет строку нулями слева
//
// Параметры:
//  Строка      - Строка - исходная строка, которую необходимо дополнить символами до заданной длины
//  ДлинаСтроки - Число - требуемая конечная длина строки
//  Символ      - Строка - (необязательный) значение символа, которым необходимо дополнить строку
//  Режим       - Строка - (необязательный) [Слева|Справа] режим добавления символов к исходной строке: слева или справа
// 
// Пример 1:
// Строка = "1234"; ДлинаСтроки = 10; Символ = "0"; Режим = "Слева"
// Возврат: "0000001234"
//
// Пример 2:
// Строка = " 1234  "; ДлинаСтроки = 10; Символ = "#"; Режим = "Справа"
// Возврат: "1234######"
//
// Возвращаемое значение:
//  Строка - строка, дополненная символами слева или справа
//
Функция ДополнитьСтроку(Знач Строка, Знач ДлинаСтроки, Знач Символ = "0", Знач Режим = "Слева") Экспорт
	
	Если ПустаяСтрока(Символ) Тогда
		Символ = "0";
	КонецЕсли;
	
	// длина символа не должна превышать единицы
	Символ = Лев(Символ, 1);
	
	// удаляем крайние пробелы слева и справа строки
	Строка = СокрЛП(Строка);
	
	КоличествоСимволовНадоДобавить = ДлинаСтроки - СтрДлина(Строка);
	
	Если КоличествоСимволовНадоДобавить > 0 Тогда
		
		СтрокаДляДобавления = СформироватьСтрокуСимволов(Символ, КоличествоСимволовНадоДобавить);
		
		Если ВРег(Режим) = "СЛЕВА" Тогда
			
			Строка = СтрокаДляДобавления + Строка;
			
		ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
			
			Строка = Строка + СтрокаДляДобавления;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

// Удаляет повторяющиеся символы слева/справа в переданной строке
//
// Параметры:
//  Строка      - Строка - исходная строка, из которой необходимо удалить повторяющиеся символы
//  Символ      - Строка - значение символа, который необходимо удалить
//  Режим       - Строка - (необязательный) [Слева|Справа] режим добавления символов к исходной строке: слева или справа
//
Функция УдалитьПовторяющиесяСимволы(Знач Строка, Знач Символ, Знач Режим = "Слева") Экспорт
	
	Если ВРег(Режим) = "СЛЕВА" Тогда
		
		Пока Лев(Строка, 1)= Символ Цикл
			
			Строка = Сред(Строка, 2);
			
		КонецЦикла;
		
	ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
		
		Пока Прав(Строка, 1)= Символ Цикл
			
			Строка = Лев(Строка, СтрДлина(Строка) - 1);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Строка;
КонецФункции

// Получает номер версии конфигурации без номера сборки
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС – номер сборки, который будет удален
// 
//  Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = РазложитьСтрокуВМассивПодстрок(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции

//Выполняет в строке ГДЕ замену символов ЧТО на соответствующие по номерам символы из строки НаЧто
//
// Параметры:
//  Что		- Строка - строка символов, каждый из которых будет заменен
//  Где		- Строка - исходная строка, в которой будет выполняться замена
//  НаЧто	- Строка - строка символов, на каждый из которых нужно заменить исходные символы
// 
//  Возвращаемое значение:
//  Строка - строка с замененными символами
//
Функция ЗаменитьОдниСимволыДругими(Что, Где, НаЧто) Экспорт
	
	Рез = Где;
	
	Для Сч = 1 По СтрДлина(Что) Цикл
		Рез = СтрЗаменить(Рез, Сред(Что, Сч, 1), Сред(НаЧто, Сч, 1));
	КонецЦикла;
	
	Возврат Рез;
	
КонецФункции

// Выполняет преобразование арабского числа в римское
//
// Параметры
//		АрабскоеЧисло			- число, целое, от 0 до 999
//		ИспользоватьКириллицу	- булево, использовать в качестве арабских цифр кириллицу или латиницу
//
// Возвращаемое значение
//		Строка
//
// Описание
//		записывает "обычное" число римскими цифрами,
//		например:
//				ПреобразоватьЧислоВРимскуюНотацию(17) = "ХVII"
//
Функция ПреобразоватьЧислоВРимскуюНотацию(АрабскоеЧисло, ИспользоватьКириллицу = Истина) Экспорт
	
	РимскоеЧисло	= "";
	АрабскоеЧисло	= ДополнитьСтроку(АрабскоеЧисло, 3);
	
	Если ИспользоватьКириллицу Тогда
		c1 = "1"; c5 = "У"; c10 = "Х"; c50 = "Л"; c100 ="С"; c500 = "Д"; c1000 = "М";
		
	Иначе
		c1 = "I"; c5 = "V"; c10 = "X"; c50 = "L"; c100 ="C"; c500 = "D"; c1000 = "M";
		
	КонецЕсли;
	
	Единицы	= Число(Сред(АрабскоеЧисло, 3, 1));
	Десятки	= Число(Сред(АрабскоеЧисло, 2, 1));
	Сотни	= Число(Сред(АрабскоеЧисло, 1, 1));
	
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(Сотни,   c100, c500, c1000);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(Десятки, c10,  c50,  c100);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(Единицы, c1,   c5,   c10);
	
	Возврат РимскоеЧисло;
	
КонецФункции //ПреобразоватьЧислоВРимскуюНотацию

// Выполняет преобразование римского числа в арабское
//
// Параметры
//		РимскоеЧисло			- строка, число, записанное римскими цифрами
//		ИспользоватьКириллицу	- булево, использовать в качестве арабских цифр кириллицу или латиницу
//
// Возвращаемое значение
//		Число
//
// Описание
//		преобразует число, записанное римскими цифрами, в "обычное" число,
//		например:
//				ПреобразоватьЧислоВАрабскуюНотацию("ХVII") = 17
//
Функция ПреобразоватьЧислоВАрабскуюНотацию(РимскоеЧисло, ИспользоватьКириллицу = Истина) Экспорт
	
	АрабскоеЧисло=0;
	
	Если ИспользоватьКириллицу Тогда
		c1 = "1"; c5 = "У"; c10 = "Х"; c50 = "Л"; c100 ="С"; c500 = "Д"; c1000 = "М";
		
	Иначе
		c1 = "I"; c5 = "V"; c10 = "X"; c50 = "L"; c100 ="C"; c500 = "D"; c1000 = "M";
		
	КонецЕсли;
	
	РимскоеЧисло = СокрЛП(РимскоеЧисло);
	ЧислоСимволов = СтрДлина(РимскоеЧисло);
	
	Для Сч=1 По ЧислоСимволов Цикл
		Если Сред(РимскоеЧисло,Сч,1) = c1000 Тогда
			АрабскоеЧисло = АрабскоеЧисло+1000;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c500 Тогда
			АрабскоеЧисло = АрабскоеЧисло+500;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c100 Тогда
			Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c500) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c1000)) Тогда
				АрабскоеЧисло = АрабскоеЧисло-100;
			Иначе
				АрабскоеЧисло = АрабскоеЧисло+100;
			КонецЕсли;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c50 Тогда
			АрабскоеЧисло = АрабскоеЧисло+50;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c10 Тогда
			Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c50) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c100)) Тогда
				АрабскоеЧисло = АрабскоеЧисло-10;
			Иначе
				АрабскоеЧисло = АрабскоеЧисло+10;
			КонецЕсли;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c5 Тогда
			АрабскоеЧисло = АрабскоеЧисло+5;
		ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c1 Тогда
			Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c5) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c10)) Тогда
				АрабскоеЧисло = АрабскоеЧисло-1;
			Иначе
				АрабскоеЧисло = АрабскоеЧисло+1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат АрабскоеЧисло;
	
КонецФункции //ПреобразоватьЧислоВАрабскуюНотацию

// Выполняет преобразование цифры в римскую нотацию 
//
// Параметры
//		Цифра - число, целое, от 0 до 9
//      РимскаяЕдиница,РимскаяПятерка,РимскаяДесятка - строки, соответствующие римские цифры
//
// Возвращаемое значение
//		Строка
//
// Описание
//		записывает "обычную" цифру римскими цифрами,
//		например:
//				ПреобразоватьЦифруВРимскуюНотацию(7,"I","V","X") = "VII"
//
Функция ПреобразоватьЦифруВРимскуюНотацию(Цифра,РимскаяЕдиница,РимскаяПятерка,РимскаяДесятка)
	
	РимскаяЦифра="";
	Если Цифра = 1 Тогда
		РимскаяЦифра = РимскаяЕдиница
	ИначеЕсли Цифра = 2 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 3 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 4 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяПятерка;
	ИначеЕсли Цифра = 5 Тогда
		РимскаяЦифра = РимскаяПятерка;
	ИначеЕсли Цифра = 6 Тогда
		РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница;
	ИначеЕсли Цифра = 7 Тогда
		РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 8 Тогда
		РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 9 Тогда
		РимскаяЦифра = РимскаяЕдиница + РимскаяДесятка;
	КонецЕсли;
	Возврат РимскаяЦифра;
	
КонецФункции //ПреобразоватьЦифруВРимскуюНотацию

// Функция возвращает строку состоящую только из цифр и специальных символов
//
// Параметры
//  Значение           - Строка - преобразуемая строка
//  ВключаяСпецСимволы - Булево - если истина то символы ".", ",", "-" 
//                                будут включены в результирующею строку
//
// Возвращаемое значение:
//   Строка   - результат преобразования
//
Функция ТолькоЦифры(Значение, ВключаяСпецСимволы = Истина) Экспорт
    СтрокаСравнения = "0123456789" + ?(ВключаяСпецСимволы, ".,", "");
	
	Результат = "";
	
	Граница = СтрДлина(Значение);
	
	Если ВключаяСпецСимволы И Лев(Значение, 1) = "-" Тогда	
		Начало = 2;		
		
		ДопСимвол = "-";
	Иначе		
		Начало = 1;	
		
		ДопСимвол = "";
	КонецЕсли; 
	
	Для Позиция = Начало По Граница Цикл
	    Символ = Сред(Значение, Позиция, 1);
		
		Если Найти(СтрокаСравнения, Символ) Тогда
		
			Результат = Результат + Символ;
		
		КонецЕсли; 			
	КонецЦикла; 

	Если ПустаяСтрока(Результат) Тогда
	
		Возврат "0";
	
	КонецЕсли; 
	
	Возврат ДопСимвол + Результат;
КонецФункции // ТолькоЦифры()

// Функция возвращает строку дополненную лидирующими нулями до указанной длинны (если длина строки меньше указанной) 
//
// Параметры
//  Значение           - Строка - преобразуемая строка
//  Длина              - Число  - требуемая длина строки 
//
// Возвращаемое значение:
//   Строка   - результат преобразования
//
Функция ДобавитьЛидирующиеНули(Значение, Длина) Экспорт
	
	Результат = "";
	Разность = Длина - СтрДлина(Значение);
	Для Счетчик = 1 По Разность Цикл
		Результат = Результат + "0";
	КонецЦикла; 

	Возврат Результат + Значение;
КонецФункции // ДобавитьЛидирующиеНули()

// Функция возвращает строку без лидирующих нулей
//
// Параметры
//	Значние - Строка - Преобразуемая строка	
Функция ОбрезатьЛидирующиеНули(Знач Значение) Экспорт
	Пока Лев(Значение, 1) = "0" Цикл
		Значение = Сред(Значение, 2)
	КонецЦикла;
	Возврат Значение
КонецФункции

// Проверяет, содержит ли строка только символы кириллического алфавита.
//
// Параметры:
//  УчитыватьРазделителиСлов - Булево - учитывать ли разделители слов или они являются исключением.
//  ДопустимыеСимволы - строка для проверки.
//
// Возвращаемое значение:
//  Истина       - строка содержит только кириллические (или допустимые) символы или пустая;
//  Ложь         - строка содержит не только кириллические (или допустимые) символы.
//
Функция ТолькоКириллицаВСтроке(Знач СтрокаПроверки, Знач УчитыватьРазделителиСлов = Истина, ДопустимыеСимволы = "") Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	КодыДопустимыхСимволов = Новый Массив;
	КодыДопустимыхСимволов.Добавить(1105); // "ё"
	КодыДопустимыхСимволов.Добавить(1025); // "Ё"
	
	Для а = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		КодыДопустимыхСимволов.Добавить(КодСимвола(Сред(ДопустимыеСимволы, а, 1)));
	КонецЦикла;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если ((КодСимвола < 1040) Или (КодСимвола > 1103)) 
			И (КодыДопустимыхСимволов.Найти(КодСимвола) = Неопределено) 
			И Не (Не УчитыватьРазделителиСлов И ЭтоРазделительСлов(КодСимвола)) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Проверяет, содержит ли строка только символы латинского алфавита.
//
// Параметры:
//  УчитыватьРазделителиСлов - Булево - учитывать ли разделители слов или они являются исключением.
//  ДопустимыеСимволы - строка для проверки.
//
// Возвращаемое значение:
//  Истина       - строка содержит только латинские (или допустимые) символы;
//  Ложь         - строка содержит не только латинские (или допустимые) символы.
//
Функция ТолькоЛатиницаВСтроке(Знач СтрокаПроверки, Знач УчитыватьРазделителиСлов = Истина, ДопустимыеСимволы = "") Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	КодыДопустимыхСимволов = Новый Массив;
	
	Для а = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		КодыДопустимыхСимволов.Добавить(КодСимвола(Сред(ДопустимыеСимволы, а, 1)));
	КонецЦикла;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если ((КодСимвола < 65) Или (КодСимвола > 90 И КодСимвола < 97) Или (КодСимвола > 122))
			И (КодыДопустимыхСимволов.Найти(КодСимвола) = Неопределено) 
			И Не (Не УчитыватьРазделителиСлов И ЭтоРазделительСлов(КодСимвола)) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей.
//
// Возвращаемое значение:
//  Булево - истина, если символ является разделителем.
//
Функция ЭтоРазделительСлов(КодСимвола, РазделителиСлов = Неопределено) Экспорт
	
	Если РазделителиСлов <> Неопределено Тогда
		Возврат Найти(РазделителиСлов, Символ(КодСимвола)) > 0;
	КонецЕсли;
		
	Диапазоны = Новый Массив;
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 48, 57)); 		// цифры
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 65, 90)); 		// латиница большие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 97, 122)); 		// латиница маленькие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1040, 1103)); 	// кириллица
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 95, 95)); 		// символ "_"
	
	Для Каждого Диапазон Из Диапазоны Цикл
		Если КодСимвола >= Диапазон.Мин И КодСимвола <= Диапазон.Макс Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Преобразует разницу во времени (выражается в секундах) в удобочитаемый формат, например 99999 -> 2:46:39
Функция ПривестиСекундыКУдобочитаемойФорме(Знач КоличествоСекунд) Экспорт
	Часы = Цел(КоличествоСекунд /3600);
	КоличествоСекунд = КоличествоСекунд - Часы * 3600;
	Минуты = Цел(КоличествоСекунд /60);
	Секунды = КоличествоСекунд - Минуты * 60;
	Возврат "" + ?(Часы > 0, Формат(Часы, "") + ":", "") + Формат(Минуты, "ЧЦ=2; ЧН=00; ЧВН=") + ":" + Формат(Секунды, "ЧЦ=2; ЧН=00; ЧВН=")
КонецФункции

// Преобразует переданный размер в Байтах в удобочитаемый формат - КБ, МБ, ГБ...
//
Функция ПривестиРазмерФайлаКУдобочитаемойФорме(Знач РазмерФайлаВБайтах) Экспорт
	
	ПредставлениеСвободногоМеста = " КМГТПЭ";
	Шаг = 1;
	Пока РазмерФайлаВБайтах / 1024 > 1 Цикл
		РазмерФайлаВБайтах = РазмерФайлаВБайтах / 1024;
		Шаг = Шаг + 1
	КонецЦикла;
	Возврат "" + Окр(РазмерФайлаВБайтах, 2) + " " + СокрЛП(Сред(ПредставлениеСвободногоМеста, Шаг, 1)) + "Б"
КонецФункции

Функция ПросклонятьСтроку(Знач СтрокаКоторуюТребуетсяПросклонять, Падеж, Пол = Неопределено) Экспорт
	
	#Если Сервер тогда	
	Если ПараметрыСеанса.ЭтоLinuxСервер тогда
		Возврат ОбщегоНазначенияСервер.ПросклонятьСтрокуLin(СтрокаКоторуюТребуетсяПросклонять, Падеж, Пол);
	Иначе
		Возврат ПросклонятьСтрокуWin(СтрокаКоторуюТребуетсяПросклонять, Падеж, Пол);
	КонецЕсли;	
	#Иначе
	Если ЭтоLinuxКлиент тогда
		Возврат ОбщегоНазначенияСервер.ПросклонятьСтрокуLin(СтрокаКоторуюТребуетсяПросклонять, Падеж, Пол);
	Иначе
		Возврат ПросклонятьСтрокуWin(СтрокаКоторуюТребуетсяПросклонять, Падеж, Пол);
	КонецЕсли;
	#КонецЕсли
	
КонецФункции

Функция ПросклонятьСтрокуWin(Знач СтрокаКоторуюТребуетсяПросклонять, Падеж, Пол = Неопределено)
	
	Если ТипЗнч(СтрокаКоторуюТребуетсяПросклонять) <> Тип("Строка") тогда
		СтрокаСклонения = Строка(СтрокаКоторуюТребуетсяПросклонять);
	Иначе
		СтрокаСклонения = СтрокаКоторуюТребуетсяПросклонять;
	КонецЕсли;	
	
	Результат = ПросклонятьСтрокуЦеликом(СтрокаСклонения,Падеж,Пол);
	
	Если Не ЗначениеЗаполнено(Результат) тогда
		
		ОбщегоНазначенияСервер.ПодключитьВнешнююКомпоненту_Сервер("ОбщийМакет.КомпонентаСклоненияФИО", "Decl", "1CNameDeclWin64.dll");
		//Компонента = Новый("AddIn.Decl");
		//ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаСклоненияФИО", "Decl");
		Компонента = Новый("AddIn.Decl.CNameDecl");
		Результат = "";
		МассивСтрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаСклонения, " ");
		
		Для	Каждого Слово Из МассивСтрок Цикл
			
			РезультатСклонения = Слово;
			Если СтроковыеФункцииКлиентСервер.ТолькоКириллицаВСтроке(Слово) Тогда
				Попытка
					Если Пол = ПредопределенноеЗначение("Перечисление.ПолКорреспондентаФизЛица.Мужской") Тогда
						РезультатСклонения = Компонента.Просклонять(Слово, Падеж, 1)
					ИначеЕсли Пол = ПредопределенноеЗначение("Перечисление.ПолКорреспондентаФизЛица.Женский") Тогда
						РезультатСклонения = Компонента.Просклонять(Слово, Падеж, 2)
					Иначе
						РезультатСклонения = Компонента.Просклонять(Слово, Падеж)
					КонецЕсли
				Исключение
				КонецПопытки
			КонецЕсли;
			
			Результат = Результат + " " + РезультатСклонения
		КонецЦикла;
		
	КонецЕсли;
	
	Результат = СокрЛП(Результат);
	
	Возврат Результат;
	
КонецФункции

// Склоняет ФИО целиком, а не пословно, так склоняет правильнее
// Параметры:
//  ФИО - Строка - Строка, которую необходимо просклонять.
//	Падеж - Число - Падеж (обязательный), в который необходимо поставить ФИО.
//   1 - Именительный
//   2 - Родительный
//   3 - Дательный
//   4 - Винительный
//   5 - Творительный
//   6 - Предложный
//
//  Пол (необязательный) - тип Перечисление.ПолФизическогоЛица - пол физического лица
Функция ПросклонятьСтрокуЦеликом(Знач ФИО, Падеж, Пол = Неопределено) Экспорт
	
	ОбщегоНазначенияСервер.ПодключитьВнешнююКомпоненту_Сервер("ОбщийМакет.КомпонентаСклоненияФИО", "Decl", "1CNameDeclWin64.dll");
	
	Компонента = Новый("AddIn.Decl.CNameDecl");
	РезультатСклонения = "";
	Попытка
		Если Пол = ПредопределенноеЗначение("Перечисление.ПолКорреспондентаФизЛица.Мужской") Тогда
			РезультатСклонения = Компонента.Просклонять(ФИО, Падеж, 1)
		ИначеЕсли Пол = ПредопределенноеЗначение("Перечисление.ПолКорреспондентаФизЛица.Женский") Тогда
			РезультатСклонения = Компонента.Просклонять(ФИО, Падеж, 2)
		Иначе
			РезультатСклонения = Компонента.Просклонять(ФИО, Падеж)
		КонецЕсли
	Исключение
	КонецПопытки;
	
	Возврат СокрЛП(РезультатСклонения);
КонецФункции

// Функция возвращает строку поиска элемента адреса без адресных сокращений
//
// Параметры
//  СтрокаПоиска  - Строка - строка поиска адреса
//  АдресныеСокращения - Массив - Массив адресных сокращений
//
// Возвращаемое значение:
//   Строка   - строка поиска без адресных сокращений
//
Функция ПодготовитьСтрокуПоиска(Знач СтрокаПоиска, АдресныеСокращения) экспорт
    СтрокаПоиска = " " + ВРег(СтрокаПоиска) + " ";
	
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, ",", " ");
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, ".", " ");
	
	Для каждого Сокращение Из АдресныеСокращения Цикл
	
		СтрокаПоиска = СтрЗаменить(СтрокаПоиска, " " + ВРег(Сокращение) + " ", " ");
	
	КонецЦикла;		
	
	Возврат СокрЛП(СтрокаПоиска);

КонецФункции

Функция СтрЗаменитьСПроверкой(Знач Строка, Знач ПодстрокаПоиска, Знач ПодстрокаЗамены) Экспорт
	
	Если СтрНайти(Строка, ПодстрокаПоиска) = 0 тогда
		ВызватьИсключение "На найдена заменяемая строка";
	КонецЕсли;
	
	Возврат СтрЗаменить(Строка, ПодстрокаПоиска, ПодстрокаЗамены);
		
КонецФункции

// Форматирует строку в соответствии с заданным шаблоном.
// Возможные значения тегов в шаблоне:
// - <span style='Имя свойства: Имя элемента стиля'>Строка</span> - оформляет текст описанными в атрибуте style
// элементами стиля. - <b> Строка </b> - выделяет строку элементом стиля ВажнаяНадписьШрифт, который соответствует
// полужирному шрифту. - <a href='Ссылка'>Строка</a> - добавляет гиперссылку.
// - <img src='Календарь'> - добавляет картинку из библиотеки картинок.
// Атрибут style применяется для оформления текста. Атрибут может быть использован для тегов span и a.
// Вначале следует имя стилевого свойства, затем через двоеточие имя элемента стиля.
// Стилевые свойства:
//  - color - Определяет цвет текста. Например, color: ГиперссылкаЦвет;
//  - background-color - Определяет цвет фона у текста. Например, background-color: ИтогиФонГруппы;
//  - font - Определяет шрифт текста.Например, font: ОсновнойЭлементСписка.
// Стилевые свойства разделяются точкой с запятой. Например, style='color: ГиперссылкаЦвет; font: ОсновнойЭлементСписка'
// Вложенные теги не поддерживаются.
//
// Параметры:
//  ШаблонСтроки - Строка - строка, содержащая теги форматирования.
//  Параметр<n>  - Строка - значение подставляемого параметра.
//
// Возвращаемое значение:
//  ФорматированнаяСтрока - преобразованная строка.
//
// Пример:
//  1. СтроковыеФункцииКлиент.ФорматированнаяСтрока(НСтр("ru='
//       <span style=""color: ЗаблокированныйРеквизитЦвет; font: ВажнаяНадписьШрифт"">Минимальная</span> версия программы <b>1.1</b>.
//       <a href = ""Обновление"">Обновите</a> программу.'"));
//  2. СтроковыеФункцииКлиент.ФорматированнаяСтрока(НСтр("ru='Режим: <img src=""РедактироватьВДиалоге"">
//       <a style=""color: ИзмененноеЗначениеРеквизитаЦвет; background-color: ИзмененноеЗначениеРеквизитаФон""
//       href=""e1cib/command/Обработка.Редактор"">Редактирование</a>'"));
//  3. СтроковыеФункцииКлиент.ФорматированнаяСтрока(НСтр("ru='Текущая дата <img src=""Календарь"">
//       <span style=""font:ВажнаяНадписьШрифт"">%1</span>'"), ТекущаяДатаСеанса());
//
Функция ФорматированнаяСтрока(Знач ШаблонСтроки, Знач Параметр1 = Неопределено, Знач Параметр2 = Неопределено,
	Знач Параметр3 = Неопределено, Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено) Экспорт
	
	ЭлементыСтиля = ОбщегоНазначенияСервер.ЭлементыСтиля();
	Возврат СтроковыеФункцииКлиентСервер.СформироватьФорматированнуюСтроку(ШаблонСтроки, ЭлементыСтиля, Параметр1, Параметр2, Параметр3, Параметр4, Параметр5);
	
КонецФункции

Функция СформироватьФорматированнуюСтроку(ШаблонСтроки, ЭлементыСтиля,
		Знач Параметр1, Знач Параметр2, Знач Параметр3, Знач Параметр4, Знач Параметр5) Экспорт
	
	HTMLСтрока = ПодставитьПараметрыВСтроку(ШаблонСтроки, Параметр1, Параметр2, Параметр3, Параметр4, Параметр5);
	
	НаборСтрок = Новый Массив;
	
	ТекущийШрифт  = Неопределено;
	ТекущийЦвет   = Неопределено;
	ТекущийФон    = Неопределено;
	ТекущаяСсылка = Неопределено;
	
	ФрагментыСтроки = СтрРазделить(HTMLСтрока, "<", Истина);
	Для каждого Фрагмент Из ФрагментыСтроки Цикл
		
		ТелоСтроки = "";
		ПозицияТэг = СтрНайти(Фрагмент, ">");
		
		Если ПозицияТэг = 0 Тогда
			ТелоСтроки = Фрагмент;
			
		ИначеЕсли СтрНачинаетсяС(Фрагмент, "/") Тогда
			ТелоСтроки = Сред(Фрагмент, ПозицияТэг + 1);
			
			ТекущийШрифт  = Неопределено;
			ТекущийЦвет   = Неопределено;
			ТекущийФон    = Неопределено;
			ТекущаяСсылка = Неопределено;
			
		Иначе
			
			ОписаниеТэга = Лев(Фрагмент, ПозицияТэг - 1);
			ПервыйПробел = СтрНайти(ОписаниеТэга, " ");
			
			Если ПервыйПробел > 0 Тогда
				ИмяТега = СокрЛП(Лев(ОписаниеТэга, ПервыйПробел));
				
				ОписаниеАтрибутов = Сред(ОписаниеТэга, ПервыйПробел + 1);
				ОписаниеАтрибутов = СтрЗаменить(ОписаниеАтрибутов , """", "'");
				
				ПозицияРавно = СтрНайти(ОписаниеАтрибутов, "=");
				Пока ПозицияРавно > 0 Цикл
					
					ИмяАтрибута = СокрЛП(Лев(ОписаниеАтрибутов, ПозицияРавно - 1));
					ПозицияПерваяКавычка = СтрНайти(ОписаниеАтрибутов, "'",, ПозицияРавно + 1);
					Если ПозицияПерваяКавычка = 0 Тогда
						ПозицияПерваяКавычка = ПозицияРавно;
					КонецЕсли;
					ПозицияВтораяКавычка = СтрНайти(ОписаниеАтрибутов, "'",, ПозицияПерваяКавычка + 1);
					Если ПозицияВтораяКавычка = 0 Тогда
						ПозицияВтораяКавычка = СтрДлина(ОписаниеАтрибутов) + 1;
					КонецЕсли;
					ЗначениеАтрибута  = СокрЛП(Сред(ОписаниеАтрибутов, ПозицияПерваяКавычка + 1,  ПозицияВтораяКавычка - ПозицияПерваяКавычка - 1));
					
					Если СтрСравнить(ИмяАтрибута, "style") = 0 Тогда
						УстановитьСтилиПоЗначениюАтрибута(ЗначениеАтрибута, ЭлементыСтиля, ТекущийФон, ТекущийЦвет, ТекущийШрифт);
					ИначеЕсли СтрСравнить(ИмяАтрибута, "href") = 0 И СтрСравнить(ИмяТега, "a") = 0 Тогда
						ТекущаяСсылка = ЗначениеАтрибута;
					ИначеЕсли СтрСравнить(ИмяАтрибута, "src") = 0 И СтрСравнить(ИмяТега, "img") = 0 Тогда
						НаборСтрок.Добавить(Новый ФорматированнаяСтрока(БиблиотекаКартинок[ЗначениеАтрибута], ТекущийШрифт, ТекущийЦвет, ТекущийФон, ТекущаяСсылка));
					КонецЕсли;
					
					ОписаниеАтрибутов = Сред(ОписаниеАтрибутов, ПозицияВтораяКавычка + 1);
					ПозицияРавно = СтрНайти(ОписаниеАтрибутов, "=");
					
				КонецЦикла;
			Иначе
				ИмяТега = ОписаниеТэга;
			КонецЕсли;
			
			Если ИмяТега = "b" Тогда
				ТекущийШрифт = ЭлементыСтиля["ВажнаяНадписьШрифт"];
			КонецЕсли;
			
			ТелоСтроки = Сред(Фрагмент, ПозицияТэг + 1);
			
		КонецЕсли;
		
		ТелоСтроки = СтрЗаменить(ТелоСтроки, "&lt;", "<");
		Если СтрДлина(ТелоСтроки) > 0 Тогда
			НаборСтрок.Добавить(Новый ФорматированнаяСтрока(ТелоСтроки, ТекущийШрифт, ТекущийЦвет, ТекущийФон, ТекущаяСсылка));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Новый ФорматированнаяСтрока(НаборСтрок);

КонецФункции

Процедура УстановитьСтилиПоЗначениюАтрибута(Знач ОписаниеСтиля, ЭлементыСтиля, ТекущийФон, ТекущийЦвет, ТекущийШрифт)
	
	Стили = СтрРазделить(ОписаниеСтиля, ";");
	
	Для каждого Стиль Из Стили Цикл
		
		ЗначенияСтиля = СтрРазделить(стиль, ":");
		ИмяСтиля      = СокрЛП(ЗначенияСтиля[0]);
		ЗначениеСтиля = СокрЛП(ЗначенияСтиля[1]);
		
		Если СтрСравнить(ИмяСтиля, "color") = 0  Тогда
			ТекущийЦвет = ЭлементыСтиля[ЗначениеСтиля];
		ИначеЕсли СтрСравнить(ИмяСтиля, "background-color") = 0 Тогда
			ТекущийФон = ЭлементыСтиля[ЗначениеСтиля];
		ИначеЕсли СтрСравнить(ИмяСтиля, "font") = 0 Тогда
			ТекущийШрифт = ЭлементыСтиля[ЗначениеСтиля];
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Транслит

// Преобразует исходную строку в транслит.
Функция СтрокаЛатиницей(Знач Строка, Соответствие = Неопределено) Экспорт
	
	Если Соответствие = Неопределено Тогда
		Соответствие = СоответствиеКириллицыИЛатиницы();
	КонецЕсли;	
	
	Возврат СтрокаВДругомАлфавите(Строка, Соответствие);
КонецФункции

Функция СоответствиеКириллицыИЛатиницы()
	// Транслитерация, используемая в загранпаспортах 1997-2010.
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("а","a");
	Соответствие.Вставить("б","b");
	Соответствие.Вставить("в","v");
	Соответствие.Вставить("г","g");
	Соответствие.Вставить("д","d");
	Соответствие.Вставить("е","e");
	Соответствие.Вставить("ё","e");
	Соответствие.Вставить("ж","zh");
	Соответствие.Вставить("з","z");
	Соответствие.Вставить("и","i");
	Соответствие.Вставить("й","y");
	Соответствие.Вставить("к","k");
	Соответствие.Вставить("л","l");
	Соответствие.Вставить("м","m");
	Соответствие.Вставить("н","n");
	Соответствие.Вставить("о","o");
	Соответствие.Вставить("п","p");
	Соответствие.Вставить("р","r");
	Соответствие.Вставить("с","s");
	Соответствие.Вставить("т","t");
	Соответствие.Вставить("у","u");
	Соответствие.Вставить("ф","f");
	Соответствие.Вставить("х","kh");
	Соответствие.Вставить("ц","ts");
	Соответствие.Вставить("ч","ch");
	Соответствие.Вставить("ш","sh");
	Соответствие.Вставить("щ","shch");
	Соответствие.Вставить("ъ","""");
	Соответствие.Вставить("ы","y");
	Соответствие.Вставить("ь",""); // пропускается
	Соответствие.Вставить("э","e");
	Соответствие.Вставить("ю","yu");
	Соответствие.Вставить("я","ya");
	
	Возврат Соответствие;
КонецФункции

Функция СтрокаВДругомАлфавите(Строка, ДругойАлфавит) Экспорт
	
	Результат = "";
	ПредыдущийСимвол = "";
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Позиция, 1);
		ПереведенныйСимвол = ДругойАлфавит[НРег(Символ)]; // Поиск соответствия без учета регистра.
		Если ПереведенныйСимвол = Неопределено Тогда
			// Другие символы остаются "как есть".
			ПереведенныйСимвол = Символ;
		Иначе
			Если Символ = ВРег(Символ) Тогда
				ПереведенныйСимвол = ТРег(ПереведенныйСимвол); // восстанавливаем регистр
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + ПереведенныйСимвол;
		ПредыдущийСимвол = ПереведенныйСимвол;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#Область ПрограммныйИнтерфейс

// См. СтандартныеПодсистемыКлиентСерверЛокализация.ПриЗаполненииПравилТранслитерации
//
Процедура ПриЗаполненииПравилТранслитерации(Правила) Экспорт
	
	// Транслитерация, используемая в загранпаспортах 1997-2010.
	Правила.Вставить("а","a");
	Правила.Вставить("б","b");
	Правила.Вставить("в","v");
	Правила.Вставить("г","g");
	Правила.Вставить("д","d");
	Правила.Вставить("е","e");
	Правила.Вставить("ё","e"); // АПК:163 требуется транслитерация.
	Правила.Вставить("ж","zh");
	Правила.Вставить("з","z");
	Правила.Вставить("и","i");
	Правила.Вставить("й","y");
	Правила.Вставить("к","k");
	Правила.Вставить("л","l");
	Правила.Вставить("м","m");
	Правила.Вставить("н","n");
	Правила.Вставить("о","o");
	Правила.Вставить("п","p");
	Правила.Вставить("р","r");
	Правила.Вставить("с","s");
	Правила.Вставить("т","t");
	Правила.Вставить("у","u");
	Правила.Вставить("ф","f");
	Правила.Вставить("х","kh");
	Правила.Вставить("ц","ts");
	Правила.Вставить("ч","ch");
	Правила.Вставить("ш","sh");
	Правила.Вставить("щ","shch");
	Правила.Вставить("ъ",""); // Пропускается.
	Правила.Вставить("ы","y");
	Правила.Вставить("ь",""); // Пропускается.
	Правила.Вставить("э","e");
	Правила.Вставить("ю","yu");
	Правила.Вставить("я","ya");
	
КонецПроцедуры


#КонецОбласти
